Java Design patterns
====================

# Navigation

1. [Отношения между классами](#Отношение-между-классами)
2. [Виды паттернов](#Виды-паттернов)
	* [Поведенческие](#b--Поведенчиские)
	* [Поздражающие](#c--Подражающие)
	* [Структурные](#s--Струткурные)

# Отношение между классами

```				
				|
1.  -----------◄►		|------- Агрегация (aggregation)
	<----------◄► 		|
				|
2.  -----------<>		|------- Композиция (composition) 
	<----------<>		|	
				|
3.  -------------               |------- Обобщение (generalization)
	------------>		|
				|
4.  - - - - - - -		|------- Зависимость (dependency)
    - - - - - - >		|

```


# Виды паттернов

```

1. +------+	
   |   B  |   ---------- Поведенческие 
   +------+	

2. +------+	
   |   C  |   ---------- Поздражающие	 
   +------+	

3. +------+	
   |   S  |   ---------- Структурные 
   +------+	

```



### B == Поведенчиские

1. [Цепочка обязанностей](#1-Цепочка-обязанностей--chain-of-responsibility)
2. [Команда == Command == Příkaz]()
3. [Интерпретатор]()
4. [Итератор == Iterator == Interátor]()
5. [Посредник]()
6. [Хранитель == Mementor ==]()
7. [Наблюдатель]()
8. [Состояние]()
9. [Стратегия]()
10. [Шаблонный метод]()
11. [Посетитель]()

### C == Подражающие

1. [Абстрактная фабрика]()
2. [Строитель]()
3. [Фабричный метод](#3-Фабричный-метод--factory-method) 
4. [Прототип]()
5. [Одиночка == Singelton == Jedináček]()


### S == Струткурные

1. [Адаптер]()
2. [Мост]()
3. [Компоновщик]()
4. [Декоратор]()
5. [Фасад]()
6. [Приспособлинец]()
7. [Прокси]()




# B == Поведенческие 

## 1. [Цепочка обязанностей == Chain of responsibility]()

![corS](https://upload.wikimedia.org/wikipedia/commons/6/6a/W3sDesign_Chain_of_Responsibility_Design_Pattern_UML.jpg)

## 2. [Команда == Command == Příkaz]()
## 3. [Интерпретатор]()
## 4. [Итератор == Iterator == Interátor](https://github.com/pwnsauce8/JavaDesignPatterns/tree/master/Iterator)

![img](https://github.com/pwnsauce8/JavaDesignPatterns/blob/master/READMEimg/Iterator)

#### Цель:

Позволяет пройтись по всем элементам некоторого составного объекта. Одним из важных условий при реализации паттерная является то, что итератор должен гарантировать нераскрытие внутреннего устройства объекта.

#### Для чего используется:

Для получения предварительного доступа состовного объекта, скрывая его внутренее представление.

#### Пример использования:

* Различные виды обхода составного объекта
* Упрощенный доступ к составному объекту

* В Java итераторы очень активно используются в Collection Framework. Для этих целей создан специальный interface с одноименным названием java.util.Iterator. Интерфейс содержит следующие методы:

> * **hasNext()** - возвращает буелове значение в зависимости от того, есть ли еще элементы в коллекции.
> * **next()** - возвращает следующий элемент в коллекции. В соответствии с API метод должен бросать NoSuchElementException если все элементы уже пройдены.
> * **remove()** - удаляет элемент, который был возвращен последним вызовом next. К этому методу есть некоторые вопросы :) - почему собственно он находится в интерфейсе, ведь не каждая коллекция позволяет удалять элементы, в конце концов есть read only коллекции. Именно поэтому начиная с Java 1.8 метод remove описан как default с такой реализацией по умолчанию: default void remove() { throw new UnsupportedOperationException("remove"); }


## 5. [Посредник]()
## 6. [Хранитель == Mementor ==]()
## 7. [Наблюдатель]()
## 8. [Состояние]()
## 9. [Стратегия]()
## 10. [Шаблонный метод]()
## 11. [Посетитель]()

# C == Подражающие 

## 1. [Абстрактная фабрика]()
## 2. [Строитель]()
## 3. [Фабричный метод == Factory Method](https://github.com/pwnsauce8/JavaDesignPatterns/tree/master/FactoryMethod/src/FactoryMethod) 

#### Цель:
Создание интерфейса, который создаёт объект. При этом, выбор того, экземпляр какого класса создавать
остаётся за классами, которые имплементируют данный интерфейс.

#### Для чего используется:
Для делигирования создания экземпляров, другому классу.


#### Пример использования:

* заранее неизвестно, экземпляры, какого класса нужно будет создавать;
* класс спроектирован таким образом, что создаваемые им объекты имеют свойства определённого класса.

## 4. [Прототип]()
## 5. [Одиночка == Singelton == Jedináček]()


# S == Струткурные

## 1. [Адаптер]()
## 2. [Мост]()
## 3. [Компоновщик]()
## 4. [Декоратор]()
## 5. [Фасад]()
## 6. [Приспособлинец]()
## 7. [Прокси]()
